* Wokshop proposal

We'll be implementing FastCGI backend (aka server, aka protocol, aka dispatcher)
in Racket. It'll be a full-featured implementation true to the [[http://www.mit.edu/~yandros/doc/specs/fcgi-spec.html][spec]]. FCGI is a
binary protocol so a bit of a drag to implement compared to SCGI (e.g. as was [[https://docs.racket-lang.org/scgi/][done
by Neil]]). However, it benefits from being well supported by web-servers. Both
Nginx and OpenBSD HTTPD ship it. It isn't terribly complex so one can explain it
in under 5 minutes. Because of its relatively low level binary nature yet
application level purpose, implementation spans multiple layers of Racket goodness
many of which can be designed as DSLs or Racket extensions.

We shall deliberately start by using vanilla Racket and quickly run into
limitations, little and big annoyances, questionable usability and lacking
ergonomics, then gradually pull ourselves out by extending, replacing and moulding
Racket into a better language. We want to dive deep and make extensive use of the
composable macro-machinery that Racket has built over many years and PhD
dissertations:

- try traditional bit-manipulation to feel the pain;
- steal a better solution from Erlang: bring bit twiddling by pattern-matching to
  Racket;
- extend the incredible Racket ~match~ pattern-matching language with
  bit-patterns;
- make bit pattern-matching work for streaming data;
- combine "higher-order" macros with continuations to allow users to extend the
  bit-pattern language;
- try modeling FCGI with hash-tables and structs;
- see how limiting and limited default simple inheritance and generic interfaces
  really are;
- steal a better solution from yet another language: bring prototype inheritance
  with metatables to Racket from Lua and finally make good use of the
  extraordinary Racket structs at the level of abstraction they were designed for;
- take over Racket reader and macro-expander to implement concise syntax for
  Lua-style tables, make them first class and natural to use, hide implementation
  details from the user;
- expose your new language as ~#lang~ to be on par with Racket proper, learn how
  to create Racket languages, packages, collections;
- add multiple inheritance to your language;
- keep hiding all the boilerplate code under yet more language layers;
- think about identity, relations and generic multiple dispatch, how far do you
  need to push it for this problem, how far could you really go;
- what would it take to build a system on par with Metaobject Protocol, could you
  push it beyond Metaobject Protocol;
- finally implement FCGI in your language that now features bit pattern-matching,
  Lua-style metatables, multiple inheritance and dispatch and more;
- conquer concurrency with Concurrent ML inspired synchronisation model: threads,
  mailboxes, syncable events, etc;
- let Racket custodians manage your resources safely;
- interlude: talk about safe interfaces, show Racket contract system, contrast
  with FCGI implemented in Typed Racket;
- quickly implement PHP style "write to stdout" web framework;
- think what's really limiting about web-programming and REST;
- sketch a simple FCGI script and start thinking how you would prefer to write
  web-apps;
- (re)discover continuations in the context of web-programming;
- finally implement ~#lang fcgi~ - a language of choice for an aspiring
  web-programmer;
- fortify your language(s) with contracts;
- extend your language with natural and unobtrusive logging;
- use logs to visualize FastCGI packet flow by generating UML diagrams, animate in
  a simple GUI - built, of course, in Racket;
- replace that GUI with a web-app built in your language;
- enjoy your ~#lang fcgi~.

Workshop is meant to be hands on and much less "academic" so that students may see
how Racket is used "in anger", what tools it provides, how encouraging and helpful
it may be to not "program Python/C/Go" in Racket but rather think in languages.
Not a "show and tell" but rather inspired by Racket Summer School where students
get to work through a subset of problems presented by writing Racket code.

Target audience for the workshop is, of course, someone who is curious about
Racket as a programming language programming language. However, it would also be
of interest to buddying Lispers coming from other dialects: Clojurists will surely
be eager to compare and contrast their beloved data-oriented language with an
entirely opposite approach Racket takes with its rich macro-system.

* Workshop outline

** Bit-patterns

Match binary data with bit-patterns, generate binary data from bit-patterns. Tony
shows the way with [[https://github.com/tonyg/racket-bitsyntax][racket-bitsyntax]]. We could implement a small subset then use
Tony's impelmentation. Extend Racket match with bit-patterns. Extend Tony's
bitsyntax-case with custom patterns. Implement streaming match on ports a-la
regexp-match.

** Data modeling

Try with hash-tables. Point out some weaknesses: no identity, so e.g. generics are
out; a bit too ad-hoc for the task at hand; no obvious way to signal value
missing except throwing (should we return undefined? How can we make it work
reliably?).

Try structs + single inheritance + generics. Point out some weaknesses: clunky
associative operations; built-in struct inheritance is too limiting; struct
getters and setters are way too static; too rigid for data modeling but rich and
excellent for extending Racket with new types of values while hiding
implementation details.

Having experienced some pain with the above do some interlude programming:

*** Interlude: implement gen:associative for hash-tables, alists, possibly structs

Simplify get and set operations on associative data structures and provide unified
interface. Expose this as a new ~#lang prelude~ that otherwise is like Racket.

*** Interlude: implement Clojure-style ad-hoc multimethods

We can provide implementations of hierarchies and isa-dispatch, so that students
may focus on implementing defmulti and defmethod macros. Entire implementation can
be kept well under 200-300 loc.

** Lua-style tables

Implement Lua-style tables with meta-tables. Implement prototypal inheritance,
single and multiple inheritance, classes. Show how dynamic dispatch falls out
almost for free. Sprinkle some macro magic to remove boilerplate in the above
mentioned patterns.

Even more general multiple dispatch. If we have time and desire implement full on
Metobject Protocol.

*** Extra: fancy syntax for tables

Implement ~#lang racket/tables~.

~{(k1 v1) (k2 v2)}~ to construct tables. Extended constructor that lets you
specify meta-table and control implementation details (e.g. mutability) with
keyworded options:

#+begin_src racket
  {Metaclass #:kw1 opt1
             #:kw2 opt2
             (k1 v1)
             (k2 v2)}
#+end_src

Extra getter syntax for symbolic keys e.g. t = ~{('k1 v)}~ can be accessed with
~t.k1~, ditto for setting 'k1 value.

Extra define and method call syntax:
#+begin_src racket
  (define T {})
  (define T.const 42)
  (define (T.method arg)
    (+ T.const arg))
  (T.method 1)

  ;; : implies passing receiver as the first (not shown) parameter
  (define (T:oopmethod arg)
    (+ self.const arg))
  (T:oopmethod 1)
#+end_src

** Build FastCGI dispatcher

*** Full multiplexing: connections and multiple requests per connection

Although explicitly allowed in the spec no web-server with wide adoption
implements full multiplexing. However, it isn't difficult to implement and exposes
students to Racket concurrency primitives: threads (main to accept connections,
reader, writer, request handler); mailboxes; ports and other synchronizable
events; possibly our own custom events.

*** Resource management with custodians

*** Logging with loggers

*** Tests with module+ and rackunit

** Visualize web-server <-> fcgi packet flow

Build a small GUI that generates UML diagrams from our fcgi logs.

** Finally design Application interface to fcgi

We are very much into web-framework territory here. What does it mean to build a
FastCGI application? Is it php style write whatever into stdout? Could we think of
something cooler? An ~#lang fcgi~ of some kind? RESTless web <-> app with
serializable continuations maybe (your cue Jay)?

** Face off against other implementations

Run Apache bench. How badly are we doing against [[https://kristaps.bsd.lv/kcgi/][implementation in C]]? Can we spot
problems by profiling?
